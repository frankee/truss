// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

// Package grpc provides a gRPC client for the {{.Service.Name}} service.
package client

import (
	"context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"github.com/pkg/errors"

    stdopentracing "github.com/opentracing/opentracing-go"

	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/tracing/opentracing"
	grpctransport "github.com/go-kit/kit/transport/grpc"

	// This Service
	"{{.ImportPath -}} /svc"
	pb "{{.PBImportPath -}}"
)

type Conn struct {
    conn *grpc.ClientConn
    service pb.{{.Service.Name}}Server
}

type Client struct {
    Endpoints
    connections map[string]*Connection
}

var client pb.{{.Service.Name}}Server

const FullServiceName = "{{.PackageName}}.{{.Service.Name}}"

func Instance() pb.{{.Service.Name}}Server {
    return client
}

// New returns an service backed by a gRPC client connection. It is the
// responsibility of the caller to dial, and later close, the connection.
func New(cfg *client.Config) *Client {
	var cc clientConfig

	for _, f := range options {
		err := f(&cc)
		if err != nil {
			return nil, errors.Wrap(err, "cannot apply option")
		}
	}

	clientOptions := []grpctransport.ClientOption{
		grpctransport.ClientBefore(
			contextValuesToGRPCMetadata(cc.headers)),
	}
	client := &Client{}

	{{- with $te := .}}
		{{- with $pkgName := $te.PackageName}}
			{{- range $i := $te.Service.Methods}}
            // {{ToLowCamelName $i.Name}}Endpoint
            {
                factory := client.factory(Make{{$i.Name}}Endpoint, tracer, logger)
                endpointer := sd.NewEndpointer(instancer, factory, logger)
                balancer := lb.NewRoundRobin(endpointer)
                retry := lb.Retry(cfg.Retry.Max, time.Second*time.Duration(cfg.Retry.Timeout), balancer)
                client.Endpoints.{{$i.Name}}Endpoint = retry
            }
			{{end}}
		{{end}}
	{{end}}

	return svc.Endpoints{
	{{range $i := .Service.Methods -}}
		{{$i.Name}}Endpoint:    {{ToLowCamelName $i.Name}}Endpoint,
	{{end}}
	}
}

func (s *Client) Close() error {
	for key, conn := range s.connections {
		logs.Info("closing ", key)
		conn.conn.Close()
	}

	return nil
}

func (c *Client) factory(makeEndpoint func(server pb.{{.Service.Name}}Server) endpoint.Endpoint, tracer stdopentracing.Tracer, logger log.Logger) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		// We could just as easily use the HTTP or Thrift client package to make
		// the connection to addsvc. We've chosen gRPC arbitrarily. Note that
		// the transport is an implementation detail: it doesn't leak out of
		// this function. Nice!

		var conn *Conn
		if _, ok := s.connections[instance]; !ok {
			transport, err := grpc.Dial(instance, grpc.WithInsecure())
			if err != nil {
				return nil, nil, err
			}
			grpc, err := NewGrpc(transport, tracer, logger, CtxValuesToSend(""))
			if err != nil {
                return nil, nil, err
            }
			conn = &Conn{conn:transport, service:grpc}
			s.connections[instance] = conn
		} else {
			connection = s.Connections[instance]
		}

		return makeEndpoint(connection.service), conn.conn, nil
	}
}
