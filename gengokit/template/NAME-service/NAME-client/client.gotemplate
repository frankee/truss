// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: {{.Version}}
// Version Date: {{.VersionDate}}

// Package grpc provides a gRPC client for the {{.Service.Name}} service.
package {{ToSnake .Service.Name}}_client

import (
    "io"
    "time"

    "git.aimap.io/go/logs"

    "github.com/go-kit/kit/endpoint"
    "github.com/go-kit/kit/log"
    "github.com/go-kit/kit/sd"
    "github.com/go-kit/kit/sd/lb"
    stdopentracing "github.com/opentracing/opentracing-go"
    "google.golang.org/grpc"

    wzclient "git.aimap.io/go/wayz-kit/client"

	// This Service
	pb "{{.PBImportPath -}}"
)

type Conn struct {
    conn *grpc.ClientConn
    service pb.{{.Service.Name}}Server
}

type Client struct {
    Endpoints
    connections map[string]*Conn
}

var client pb.{{.Service.Name}}Server

const FullServiceName = "{{.PackageName}}.{{.Service.Name}}"

func Instance() pb.{{.Service.Name}}Server {
    return client
}

// New returns an service backed by a gRPC client connection. It is the
// responsibility of the caller to dial, and later close, the connection.
func New(cfg *wzclient.Config, instancer sd.Instancer, tracer stdopentracing.Tracer, logger log.Logger) *Client {
	client := &Client{}

	{{- with $te := .}}
		{{- with $pkgName := $te.PackageName}}
			{{- range $i := $te.Service.Methods}}
            // {{ToLowCamelName $i.Name}}Endpoint
            {
                factory := client.factory(Make{{$i.Name}}Endpoint, tracer, logger)
                endpointer := sd.NewEndpointer(instancer, factory, logger)
                balancer := lb.NewRoundRobin(endpointer)
                retry := lb.Retry(cfg.Retry.Max, time.Second*time.Duration(cfg.Retry.Timeout), balancer)
                client.Endpoints.{{$i.Name}}Endpoint = retry
            }
			{{end}}
		{{end}}
	{{end}}

	return client
}

func (c *Client) Close() error {
	for key, conn := range c.connections {
		logs.Info("closing ", key)
		conn.conn.Close()
	}

	return nil
}

func (c *Client) factory(makeEndpoint func(server pb.{{.Service.Name}}Server) endpoint.Endpoint, tracer stdopentracing.Tracer, logger log.Logger) sd.Factory {
	return func(instance string) (endpoint.Endpoint, io.Closer, error) {
		// We could just as easily use the HTTP or Thrift client package to make
		// the connection to addsvc. We've chosen gRPC arbitrarily. Note that
		// the transport is an implementation detail: it doesn't leak out of
		// this function. Nice!

		var conn *Conn
		if _, ok := c.connections[instance]; !ok {
			transport, err := grpc.Dial(instance, grpc.WithInsecure())
			if err != nil {
				return nil, nil, err
			}
			grpc, err := NewGrpc(transport, tracer, logger, CtxValuesToSend(""))
			if err != nil {
                return nil, nil, err
            }
			conn = &Conn{conn:transport, service:grpc}
			c.connections[instance] = conn
		} else {
			conn = c.connections[instance]
		}

		return makeEndpoint(conn.service), conn.conn, nil
	}
}
